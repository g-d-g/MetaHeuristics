// Generated by CoffeeScript 1.6.3
var DifferentialEvolution, Evolution, Parallel, Q, SimulatedAnnealing, _;

_ = require('lodash-node');

Parallel = require("paralleljs");

Q = require("q");

SimulatedAnnealing = (function() {
  function SimulatedAnnealing() {}

  SimulatedAnnealing.prototype.run = function(problem, params, progress, deferred) {
    var P, champion, current, neighbour, step, steps, temp, _i;
    if (params == null) {
      params = {};
    }
    if (deferred == null) {
      deferred = Q.defer();
    }
    params = _.merge({
      steps: 100,
      temp: 1000,
      cdr: .999
    }, params);
    temp = params.temp;
    steps = params.steps;
    P = function(current, neighbour, temp) {
      return Math.random() < Math.exp((current.fitness - neighbour.fitness) / temp);
    };
    current = problem.makeRandomSolution();
    current.temp = temp;
    current.fitness = problem.fitness(current);
    champion = current;
    while (temp > 1.5) {
      for (step = _i = 0; 0 <= steps ? _i <= steps : _i >= steps; step = 0 <= steps ? ++_i : --_i) {
        neighbour = problem.findNeighbour(current);
        neighbour.temp = temp;
        neighbour.fitness = problem.fitness(neighbour);
        if (neighbour.fitness < current.fitness || P(current, neighbour, temp)) {
          current = neighbour;
        }
        if (current.fitness < champion.fitness) {
          champion = current;
        }
        if (typeof progress === "function") {
          progress({
            temperature: temp,
            best: champion
          });
        }
      }
      temp *= params.cdr;
    }
    deferred.resolve(champion);
    return deferred.promise;
  };

  return SimulatedAnnealing;

})();

Evolution = (function() {
  var evolutionize;

  function Evolution() {}

  evolutionize = function(problem, params, population, generation, progress, bestFitness, reign, deferred) {
    var best, parent, parentCandidates, parents, populate, solution, _fn, _i, _j, _k, _len, _len1, _ref, _results;
    if (reign == null) {
      reign = 0;
    }
    if (deferred == null) {
      deferred = Q.defer();
    }
    if (generation <= 0 || reign > params.stopAfterUnimprovedGenerations) {
      deferred.resolve(population);
    } else {
      parents = [];
      switch (params.selection) {
        case "deterministic":
          parents = _.sortBy(population, "fitness").slice(0, params.parents);
          best = parents[0];
          if (typeof progress === "function") {
            progress({
              generation: params.generations - generation,
              best: best,
              reign: reign
            });
          }
          break;
        case "stochastic":
          parents = params.elites > 0 ? _.sortBy(population, "fitness").slice(0, params.elites) : [];
          parentCandidates = _.without(population, parents);
          _fn = function(solution) {
            var i, _j, _ref, _results;
            _results = [];
            for (i = _j = 0, _ref = params.tournamentSize - 1; 0 <= _ref ? _j <= _ref : _j >= _ref; i = 0 <= _ref ? ++_j : --_j) {
              if (solution.score == null) {
                solution.score = 0;
              }
              if (solution.fitness < population[Math.round(Math.random() * (population.length - 1))].fitness) {
                _results.push(solution.score += 1);
              } else {
                _results.push(void 0);
              }
            }
            return _results;
          };
          for (_i = 0, _len = parentCandidates.length; _i < _len; _i++) {
            solution = parentCandidates[_i];
            _fn(solution);
          }
          _.sortBy(parentCandidates, "score").slice(-(params.parents - parents.length)).forEach(function(p) {
            delete p.score;
            return parents.push(p);
          });
          best = _.sortBy(parents, "fitness")[0];
          if (typeof progress === "function") {
            progress({
              generation: params.generations - generation,
              best: best,
              reign: reign
            });
          }
      }
      populate = function(parents) {
        var child;
        parents = _.shuffle(parents);
        if (Math.random() > params.recombinationProbability) {
          child = problem.recombine.apply(this, parents);
        } else {
          child = problem.mutate(parents[0]);
        }
        child.generation = params.generations - generation;
        child.fitness = problem.fitness(child);
        return child;
      };
      population = ((function() {
        _results = [];
        for (var _j = 0, _ref = params.populationSize - parents.length; 0 <= _ref ? _j <= _ref : _j >= _ref; 0 <= _ref ? _j++ : _j--){ _results.push(_j); }
        return _results;
      }).apply(this).map(function() {
        return parents;
      })).map(populate);
      for (_k = 0, _len1 = parents.length; _k < _len1; _k++) {
        parent = parents[_k];
        population.push(parent);
      }
      evolutionize(problem, params, population, --generation, progress, best.fitness, (best.fitness === bestFitness ? reign + 1 : 0), deferred);
    }
    return deferred.promise;
  };

  Evolution.prototype.run = function(problem, params, progress) {
    var deferred, population, _i, _ref, _results;
    params = _.merge({
      generations: 1000,
      populationSize: 200,
      selection: "deterministic",
      parents: 20,
      elites: 5,
      tournamentSize: 10,
      recombinationProbability: .5,
      stopAfterUnimprovedGenerations: 300
    }, params);
    population = (function() {
      _results = [];
      for (var _i = 0, _ref = params.populationSize - 1; 0 <= _ref ? _i <= _ref : _i >= _ref; 0 <= _ref ? _i++ : _i--){ _results.push(_i); }
      return _results;
    }).apply(this).map(function(i) {
      return problem.makeRandomSolution();
    });
    population.forEach(function(solution) {
      return solution.fitness = problem.fitness(solution);
    });
    deferred = Q.defer();
    evolutionize(problem, params, population, params.generations, progress).then(function(population) {
      return deferred.resolve(_.sortBy(population, "fitness")[0]);
    });
    return deferred.promise;
  };

  return Evolution;

})();

DifferentialEvolution = (function() {
  function DifferentialEvolution() {}

  DifferentialEvolution.prototype.run = function(problem, params) {
    if (params == null) {
      params = {};
    }
  };

  return DifferentialEvolution;

})();

exports.SimulatedAnnealing = new SimulatedAnnealing();

exports.Evolution = new Evolution();

exports.DifferentialEvolution = new DifferentialEvolution();
